import{createWebpackPlugin as N}from"unplugin";import{red as P,getCompressedSize as z,normalizePath as B,checkNodeVersion as E,normalizeOptions as O,handleErrors as $,Output as v}from"@codecov/bundler-plugin-core";import C from"node:path";import*as f from"webpack";const p=/(\w|\[|]|\/)/g,M=({assetName:e,filename:u,assetModuleFilename:n,chunkFilename:i,cssFilename:s,cssChunkFilename:o})=>{const l=e.replaceAll(p,"");return u!==""&&l.includes(u.replaceAll(p,""))?u:i!==""&&l.includes(i.replaceAll(p,""))?i:s!==""&&l.includes(s.replaceAll(p,""))?s:o!==""&&l.includes(o.replaceAll(p,""))?o:n!==""&&l.includes(n.replaceAll(p,""))?n:""},h="@codecov/webpack-plugin",w="0.0.1-beta.12",y=({output:e})=>({version:e.version,name:h,pluginVersion:w,buildStart:()=>{e.start(),e.setPlugin(h,w)},buildEnd:()=>{e.end()},writeBundle:async()=>{await e.write()},webpack(u){u.hooks.thisCompilation.tap(h,n=>{n.hooks.processAssets.tapPromise({name:h,stage:f.Compilation.PROCESS_ASSETS_STAGE_REPORT},async()=>{if(!e.bundleName||e.bundleName===""){P("Bundle name is not present or empty. Skipping upload.");return}if(e.setBundleName(e.bundleName),typeof n.outputOptions.chunkFormat=="string"){n.name&&n.name!==""&&e.setBundleName(`${e.bundleName}-${n.name}`);let t=n.outputOptions.chunkFormat;t==="commonjs"?t="cjs":t==="module"&&(t="esm"),e.setBundleName(`${e.bundleName}-${t}`)}const i=n.getStats().toJson({assets:!0,chunks:!0,modules:!0,builtAt:!0,hash:!0});e.bundler={name:"webpack",version:f.version};const s=n.outputOptions,{assets:o,chunks:l,modules:k}=i,g=[];if(o){const t=typeof s.filename=="string"?s.filename:"",a=typeof s.assetModuleFilename=="string"?s.assetModuleFilename:"",m=typeof s.chunkFilename=="string"?s.chunkFilename:"",r=typeof s.cssFilename=="string"?s.cssFilename:"",d=typeof s.chunkFilename=="string"?s.chunkFilename:"";await Promise.all(o.map(async c=>{const S=M({assetName:c.name,filename:t,assetModuleFilename:a,chunkFilename:m,cssFilename:r,cssChunkFilename:d});if(C.extname(c.name)===".map")return;const F=n.getAsset(c.name);let A=null;F&&(A=await z({fileName:c.name,code:F.source.source()})),g.push({name:c.name,size:c.size,gzipSize:A,normalized:B(c.name,S)})})),e.assets=g}const b=new Map;if(l){let t=0;e.chunks=l.map(a=>{const m=a.id??"",r=`${t}-${m}`;return b.set(m,r),t+=1,{id:a.id?.toString()??"",uniqueId:r,entry:a.entry,initial:a.initial,files:a.files??[],names:a.names??[]}})}if(k&&(e.modules=k.map(t=>{const a=t.chunks??[],m=[];return a.forEach(r=>{const d=b.get(r);d&&m.push(d)}),{name:t.name??"",size:t.size??0,chunkUniqueIds:m}})),e.duration=Date.now()-(e.builtAt??0),e.outputPath=s.path??"",e.dryRun){const{RawSource:t}=f.sources;n.emitAsset(`${e.bundleName}-stats.json`,new t(e.bundleStatsToJson()))}})})}}),R=N((e,u)=>{if(E(u))return[];const n=O(e);if(!n.success){const{shouldExit:o}=$(n);return o&&process.exit(1),[]}const i=[],s=new v(n.options);return n.options.enableBundleAnalysis&&i.push(y({output:s})),i}),_=R,x=y;export{x as _internal_webpackBundleAnalysisPlugin,_ as codecovWebpackPlugin};
//# sourceMappingURL=index.mjs.map
